from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.http import Http404
from django.conf import settings

from .models import Ingredient
from .forms import IngredientForm

import os, json, logging, re, requests

logger = logging.getLogger(__name__)

# ----------------------------
# Tunable matching thresholds
# ----------------------------
# First filter: Spoonacular's own count of matched ingredients.
SPOON_MIN_MATCHED_API = 1     # keep results with >= this many matches (Spoonacular's view)
# Second filter: your strict confirmation against the user's pantry.
SPOON_MIN_CONFIRMED = 1   # show cards even if one solid pantry match      

# classify Spoonacular dish types that imply “drink”
DRINK_TYPES = {"drink", "beverage", "beverages", "cocktail", "smoothie"}

# ----------------------------
# Helpers
# ----------------------------
def slugify(title: str) -> str:
    s = (title or "").strip().lower()
    s = re.sub(r"[^a-z0-9]+", "-", s)
    return re.sub(r"-+", "-", s).strip("-") or "recipe"

# Loose matching helpers (to better align pantry vs API names)
SYNONYMS = {
    "beef": [r"\bbeef\b", r"\bground\s+beef\b", r"\bsirloin\b", r"\bsteak\b", r"\btop\s+round\b", r"\bchuck\b"],
    "corn": [r"\bcorn\b", r"\bsweet\s+corn\b", r"\bcorn\s+on\s+the\s+cob\b", r"\bcorn\s+kernels?\b"],
    "bell pepper": [r"\bbell\s+pepper(s)?\b", r"\bred\s+pepper(s)?\b", r"\bgreen\s+pepper(s)?\b",
                    r"\byellow\s+pepper(s)?\b", r"\bcapsicum\b"],
}

def is_match(pantry_item: str, candidate: str) -> bool:
    p = (pantry_item or "").strip().lower()
    c = (candidate or "").strip().lower()
    if not p or not c:
        return False
    if p == c:
        return True
    if re.search(rf"\b{re.escape(p)}\b", c):
        return True
    if re.search(rf"\b{re.escape(c)}\b", p):
        return True
    for pat in SYNONYMS.get(p, []):
        if re.search(pat, c):
            return True
    return False

def _normalize_ingredient(name: str) -> str:
    n = (name or "").strip().lower()
    fixes = {
        r"\bbell\s*peper\b": "bell pepper",
        r"\bsweet\s*corn\b": "corn",
        r"\bscallions?\b": "green onion",
    }
    for pat, repl in fixes.items():
        n = re.sub(pat, repl, n)
    return n


# ----------------------------
# Core pages & pantry CRUD
# ----------------------------
def home(request):
    return render(request, "core/home.html")

@login_required
def dashboard(request):
    ingredients = request.user.ingredients.all()
    form = IngredientForm()
    return render(
        request,
        "core/dashboard.html",
        {"ingredients": ingredients, "form": form},
    )

@login_required
def add_ingredient(request):
    if request.method == "POST":
        form = IngredientForm(request.POST)
        if form.is_valid():
            ing = form.save(commit=False)
            ing.user = request.user
            try:
                ing.save()
                messages.success(request, f"Added {ing.name}.")
            except Exception as e:
                logger.exception("Error saving ingredient")
                messages.error(request, f"Could not add: {e}")
        else:
            messages.error(request, "Please correct the errors.")
    return redirect("dashboard")

@login_required
def delete_ingredient(request, pk):
    ing = get_object_or_404(Ingredient, pk=pk, user=request.user)
    if request.method == "POST":
        ing.delete()
        messages.info(request, f"Removed {ing.name}.")
    return redirect("dashboard")


# -------- AI image generation (OpenAI) --------
def _ai_image_for_title(title: str, kind: str, api_key: str) -> str | None:
    """
    Returns a hosted image URL generated by OpenAI Images (or None on failure).
    """
    try:
        prompt = (
            f"High quality {'cocktail' if kind=='drink' else 'food'} photo of: {title}. "
            f"{'In a glass, styled cocktail photo, studio lighting.' if kind=='drink' else 'Plated dish, natural light, appetizing.'}"
        )
        resp = requests.post(
            "https://api.openai.com/v1/images/generations",
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
            },
            json={
                "model": "gpt-image-1",
                "prompt": prompt,
                "size": "auto",
                "n": 1,
            },
            timeout=60,
        )
        if resp.status_code != 200:
            logger.warning("OpenAI image gen %s: %s", resp.status_code, resp.text)
            return None
        data = resp.json()
        url = (data.get("data") or [{}])[0].get("url")
        return url
    except Exception as e:
        logger.exception("Image generation failed")
        return None


# ----------------------------
# AI Recipes (now with kind + image URLs)
# ----------------------------
@login_required
def ai_recipes(request):
    if request.method != "POST":
        messages.error(request, "Use the button to generate AI recipes.")
        return redirect("dashboard")

    kind = (request.POST.get("kind") or "food").strip().lower()  # 'food' or 'drink'
    pantry = list(request.user.ingredients.values_list("name", flat=True))
    if not pantry:
        messages.warning(request, "Your pantry is empty. Add some ingredients first.")
        return redirect("dashboard")

    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        messages.error(request, "OpenAI API key not configured.")
        return redirect("dashboard")

    # ---- helper: generate an image URL per recipe (fixed size) ----
    def _gen_image_url(title: str, kind_: str) -> str | None:
        try:
            prompt = (
                f"High-quality, appetizing {kind_} photo: {title}. "
                "Natural lighting, minimal props, social-ready composition."
            )
            r = requests.post(
                "https://api.openai.com/v1/images/generations",
                headers={
                    "Authorization": f"Bearer {api_key}",
                    "Content-Type": "application/json",
                },
                json={
                    "model": "gpt-image-1",
                    "prompt": prompt,
                    "size": "1024x1024",  # supported sizes: 1024x1024, 1024x1536, 1536x1024, or "auto"
                },
                timeout=60,
            )
            if r.status_code == 403:
                # Org not verified for gpt-image-1 → skip images silently (with one warning)
                logger.warning("OpenAI image gen blocked (403). Skipping images this run.")
                return None

            if r.status_code != 200:
                logger.error("OpenAI image gen %s: %s", r.status_code, r.text)
                return None

            payload = r.json()
            data = payload.get("data") or []
            return data[0].get("url") if data else None

        except requests.RequestException:
            logger.exception("Network error calling OpenAI image gen")
            return None
        except Exception:
            logger.exception("Unexpected error parsing image response")
            return None

    # ---- text recipes (JSON) ----
    system_msg = (
        "You are a professional chef. Generate exactly 4 recipes based on the user's pantry. "
        "Prefer using provided ingredients; suggest smart substitutions if needed. "
        f"The recipes must be type: {kind}. "
        "Return STRICT JSON ONLY with this schema:\n"
        "{"
        "  \"recipes\": ["
        "    {"
        "      \"title\": string,"
        "      \"ingredients\": [string],"
        "      \"steps\": [string],"
        "      \"tags\": [string],"
        "      \"cook_time_minutes\": integer"
        "    }"
        "  ]"
        "}"
    )
    user_msg = f"Pantry items: {', '.join(pantry)}"

    try:
        resp = requests.post(
            "https://api.openai.com/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
            },
            json={
                "model": "gpt-4o-mini",
                "response_format": {"type": "json_object"},
                "temperature": 0.7,
                "messages": [
                    {"role": "system", "content": system_msg},
                    {"role": "user", "content": user_msg},
                ],
            },
            timeout=60,
        )
        if resp.status_code != 200:
            logger.error("OpenAI non-200 response: %s %s", resp.status_code, resp.text)
            messages.error(request, f"AI request failed ({resp.status_code}).")
            return redirect("dashboard")

        data = resp.json()
        payload = json.loads(data["choices"][0]["message"]["content"])
        recipes = (payload.get("recipes") or [])[:4]

        # Normalize + enrich, add id, and generate images
        for idx, r in enumerate(recipes, start=1):
            r["id"] = idx
            r["title"] = r.get("title") or f"Recipe {idx}"
            r["ingredients"] = r.get("ingredients") or []
            r["steps"] = r.get("steps") or []
            r["tags"] = r.get("tags") or []
            # Only try AI image if enabled
            r["image_url"] = _gen_image_url(r["title"], kind) if settings.ENABLE_AI_IMAGES else None

        # Store for detail view
        request.session["ai_recipes"] = recipes
        request.session.modified = True

        return render(request, "core/ai_results.html", {"recipes": recipes, "pantry": pantry, "kind": kind})

    except requests.RequestException as e:
        logger.exception("Network error calling OpenAI")
        messages.error(request, f"Network error calling AI: {e}")
        return redirect("dashboard")
    except (KeyError, ValueError) as e:
        logger.exception("Failed to parse AI response")
        messages.error(request, f"Failed to parse AI response: {e}")
        return redirect("dashboard")

# ----------------------------
# Web Recipes (now respects kind)
# ----------------------------
@login_required
def web_recipes(request):
    if request.method != "POST":
        messages.error(request, "Use the button to search recipes.")
        return redirect("dashboard")

    kind = (request.POST.get("kind") or "food").strip().lower()  # 'food' or 'drink'

    pantry_raw = list(request.user.ingredients.values_list("name", flat=True))
    pantry = [_normalize_ingredient(x) for x in pantry_raw if x and x.strip()]
    if not pantry:
        messages.warning(request, "Your pantry is empty.")
        return redirect("dashboard")

    api_key = os.getenv("SPOONACULAR_API_KEY")
    if not api_key:
        messages.error(request, "Spoonacular API key not set.")
        return redirect("dashboard")

    try:
        # 1) Find by ingredients
        find_resp = requests.get(
            "https://api.spoonacular.com/recipes/findByIngredients",
            params={
                "apiKey": api_key,
                "ingredients": ",".join(pantry),
                "number": 15,
                "ranking": 2,
                "ignorePantry": True,
                "fillIngredients": True,
            },
            timeout=20,
        )
        if find_resp.status_code == 429:
            messages.error(request, "Spoonacular rate limit reached. Please try again later.")
            return redirect("dashboard")
        if find_resp.status_code != 200:
            logger.error("findByIngredients %s: %s", find_resp.status_code, find_resp.text)
            messages.error(request, f"Recipe search failed ({find_resp.status_code}).")
            return redirect("dashboard")

        found = [r for r in (find_resp.json() or []) if (r.get("usedIngredientCount") or 0) >= SPOON_MIN_MATCHED_API]
        if not found:
            messages.info(request, "No good matches—try adding one more ingredient.")
            return redirect("dashboard")

        ids = [str(item["id"]) for item in found if "id" in item][:12]
        if not ids:
            messages.info(request, "No good matches—try adding one more ingredient.")
            return redirect("dashboard")

        # 2) Enrich & filter by type
        info_resp = requests.get(
            "https://api.spoonacular.com/recipes/informationBulk",
            params={"apiKey": api_key, "ids": ",".join(ids)},
            timeout=20,
        )
        if info_resp.status_code == 429:
            messages.error(request, "Spoonacular rate limit reached. Please try again later.")
            return redirect("dashboard")
        if info_resp.status_code != 200:
            logger.error("informationBulk %s: %s", info_resp.status_code, info_resp.text)
            messages.error(request, f"Recipe details failed ({info_resp.status_code}).")
            return redirect("dashboard")

        details = {str(d["id"]): d for d in info_resp.json() if "id" in d}
        pantry_set = set(pantry)

        results = []
        for item in found:
            sid = str(item.get("id"))
            det = details.get(sid, {})
            dish_types = set((det.get("dishTypes") or []) + (det.get("occasions") or []))
            is_drink = bool(dish_types & DRINK_TYPES)

            # Respect the user choice:
            if kind == "food" and is_drink:
                continue
            if kind == "drink" and not is_drink:
                continue

            # Build a reliable URL
            url = det.get("sourceUrl") or det.get("spoonacularSourceUrl")
            if not url and det.get("title") and sid:
                url = f"https://spoonacular.com/recipes/{slugify(det['title'])}-{sid}"

            # Normalize names
            def norm(s): return (s or "").strip().lower()
            used_api = [norm(u.get("name")) for u in (item.get("usedIngredients") or [])]
            missed_api = [norm(m.get("name")) for m in (item.get("missedIngredients") or [])]

            # Confirmed matches (loose)
            used_confirmed = []
            for p in pantry:
                for cand in used_api:
                    if is_match(p, cand):
                        used_confirmed.append(p)
                        break
            used_confirmed = sorted(set(used_confirmed))

            missed_clean = []
            for m in missed_api:
                if not any(is_match(p, m) for p in pantry):
                    missed_clean.append(m)
            missed_clean = sorted(set(missed_clean))

            if len(used_confirmed) < SPOON_MIN_CONFIRMED:
                continue

            results.append({
                "label": det.get("title") or item.get("title"),
                "image": det.get("image") or item.get("image"),
                "url": url,
                "readyInMinutes": det.get("readyInMinutes"),
                "servings": det.get("servings"),
                "usedIngredientCount": len(used_confirmed),
                "missedIngredientCount": len(missed_clean),
                "usedIngredients": used_confirmed,
                "missedIngredients": missed_clean,
            })

        if not results:
            messages.info(request, "No good matches. Try adding another ingredient or adjust filters.")
            return redirect("dashboard")

        return render(request, "core/web_results.html", {"results": results, "pantry": pantry, "kind": kind})

    except requests.RequestException as e:
        logger.exception("Spoonacular network error")
        messages.error(request, f"Network error calling Spoonacular: {e}")
        return redirect("dashboard")
    except Exception as e:
        logger.exception("Spoonacular parsing error")
        messages.error(request, f"Unexpected error: {e}")
        return redirect("dashboard")

def recipe_detail(request, recipe_id: int):
    recipes = request.session.get("ai_recipes") or []
    recipe = next((r for r in recipes if int(r.get("id", -1)) == recipe_id), None)
    if not recipe:
        raise Http404("Recipe not found")
    return render(request, "core/recipe_detail.html", {"recipe": recipe})